# Linux Tenets

## Summary

### 9 Major Tenets

1.	Small is beautiful
2.	Make each program do one thing well
3.	build a prototype ASAP
4.	Portability > Efficiency
5.	Store numerical data in flat files
6.	Use software leverage to your advantage (?)
7.	Use scripts for leverage & portability
8.	Avoid captive user interfaces
		-what you see is *all* you get
9.	Make every program a filter

### 10 Lesser Tenets

1.	Allow the user to tailor the environment
2.	Make system kernels small & lightweight
3.	Use lower case and keep it short
4.	Save trees(less paper?)
5.	Silence is golder(reduce output? fail silently?)
6.	Think Parallel(?)
7.	Sum of the parts is greater than the whole
		-what you see is *all* you get
8.	Look for the ninety percent solution
9.	Worse is better(??? better than not being free and customizable ? )
10.	Think hierarchically

## EXPOSITION

### Major

1.	small relates to the efficiency of m x n = e. m+n=size. m*n=expressiveness. If a language is larger it can be more expressive, but the language itself takes up more space. if m = (number of words in a language) and n=(number of words in an expression), then m x n is greatest when m and n have similar values. So depending on the requirements(e=expressiveness), the language should grow or shrink accordingly to reach maximum efficiency.
2.	words should have distinct boundaries. words should be able to be taken in and out of a language without destroying the language.
3.	development should be incremental, gradually working in features and testing(?). (Anything is possible if it is broken into small enough steps ? )
4.	Better to be Larger in Size and Lower in Speed than to be available on less systems.
5.	As everything is a text stream, for maximum configurability everything should be kept in text files
6.	?
7.	
8.	Don't ever let graphics limit usefulness- What you see is *all* you get. MY SOLUTION> what you see is *all you can get*.
9. 
